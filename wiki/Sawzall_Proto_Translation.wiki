#summary Sawzall output from the protocol compiler.

The Sawzall parser invokes the protocol compiler as a child process for each `.proto` file included into a `.szl` program using `proto` clauses.
The protocol compiler takes a `.proto` file and generates the Sawzall code for it. It can be invoked directly like so:

{{{
Usage: protoc --plugin=/full/path/to/protoc-gen-szl --szl_out=. [--import_path=PATH] PROTO_FILE.proto
}}}

Below is the mapping between the proto syntax and the corresponding Sawzall syntax for the protocol buffer format.

[#Top_Level_Statements Top-Level Statements]
      * Imports
      * Messages
      * Packages
      * Enums

[#Fields Fields]
      * Semantic Labels
      * Options
      * Scalar Types
      * Group Types
      * Message Types
      * Enums

<br>

=== Top Level Statements ===

|| *Proto* || *Sawzall* ||
|| || ||
|| *Imports* || ||
|| `import "logs/eventid/eventid.proto"` || `proto "logs/eventid/eventid.proto"` ||
|| *Messages* || ||
|| `// [parsed] message`<br>`message MyMessage {`<br>`  ...`<br>`};` || `type MyMessage = parsedmessage {`<br>`  ...`<br>`};` ||
|| *Packages* || ||
|| `package foo;`<br>`message MyMessage {`<br>`  ...`<br>`};` || `type foo.MyMessage = parsedmessage {`<br>`  ...`<br>`};` ||
|| *Enums* || ||
|| `enum Enum {`<br>`  FOO = 1;`<br>`  BAR = 2;`<br>`  BAZ = 3;`<br>`};`<br><br><br><br><br><br><br>`|| `type Enum = parsedmessage {`<br>`  type Enum = int,`<br><br>`  static FOO: Enum = 1,`<br>`  static BAR: Enum = 2,`<br>`  static BAZ: Enum = 3,`<br><br>`  static Enum_names: map[enum_value: int] `<br>`    of enum_name: string = {`<br>`    3: "BAZ",`<br>`    2: "BAR",`<br>`    1: "FOO",`<br>`  },`<br>`};`<br>`||
||`message Baz {`<br>`  required Enum required_enum = 1;`<br><br>`  optional Enum optional_enum = 2 [default = FOO];`<br><br>`  repeated Enum repeated_enum = 3;`<br><br>`};`||`type Baz = parsedmessage {`<br>`  required_enum:`<br>`    Enum @ 3: int32,`<br>`  optional_enum:`<br>`    Enum = 1 @ 4: int32`<br>`  repeated_enum: array of`<br>`    Enum @ 3: int32`<br>`};`||

<br>

=== Fields ===

|| *Proto* || *Sawzall* ||
|| || ||
|| *Semantic Labels* || ||
||`  required  bool required_bool  =  1;`<br><br>`  optional  bool optional_bool  =  2;`<br><br>`  repeated  bool repeated_bool  =  3;` ||`  required_bool:`<br>`    bool @ 1: bool,`<br>`  optional_bool:`<br>`    bool @ 2: bool,`<br>`  repeated_bool: array of`<br>`    bool @ 3: bool` ||
|| *Options* || ||
||`  required  bool  mybool1  =  1 [deprecated=true];`<br><br>`  optional  bool  mybool2  =  2 [default=true];`<br><br>`  repeated  bool  mybools  =  3 [packed=true];`||`  mybool1:`<br>`    bool @ 1: bool,`<br>`  mybool2:`<br>`    bool = true @ 2: bool,`<br>`  mybools:`<br>`    bytes @ 3: string` ||
|| *Scalar Types* || ||
||`  required    int32 required_int32     =   1;`<br><br>`  required    int64 required_int64     =   2;`<br><br>`  required   uint32 required_uint32    =   3;`<br><br>`   required   uint64 required_uint64    =   4;`<br><br>`  required   sint32 required_sint32    =   5;`<br><br>`  required   sint64 required_sint64    =   6;`<br><br>`   required  fixed32 required_fixed32   =   7;`<br><br>`  required  fixed64 required_fixed64   =   8;`<br><br>`  required sfixed32 required_sfixed32  =   9;`<br><br>`  required sfixed64 required_sfixed64  =  10;`<br><br>`   required    float required_float     =  11;`<br><br>`  required   double required_double    =  12;`<br><br>`  required   string required_string    =  13;`<br><br>`  required    bytes required_bytes     =  14;`<br><br>`   required     bool required_bool      =  15;`||`  required_int32:`<br>`    int @ 1: int32,`<br>`  required_int64:`<br>`    int @ 2: int64,`<br>`  required_uint32:`<br>`    uint @ 3: uint32,`<br>`  required_uint64:`<br>`    uint @ 4: uint64,`<br>`  required_sint32:`<br>`    int @ 5: int32,`<br>`  required_sint64:`<br>`    int @ 6: int64,`<br>`  required_fixed32:`<br>`    uint @ 7: fixed32,`<br>`  required_fixed64:`<br>`    uint @ 8: uint64,`<br>`  required_sfixed32:`<br>`    int @ 9: int32,`<br>`  required_sfixed64:`<br>`    int @ 10: int64,`<br>`  required_float:`<br>`    float @ 11: float,`<br>`  required_double:`<br>`    float @ 12: double,`<br>`  required_string:`<br>`    string @ 13:  ring,`<br>`  required_bytes:`<br>`    bytes @ 14: bytes,`<br>`  required_bool:`<br>`    bool @ 15: bool`||
|| *Group Types* || ||
||`  optional group Group = 1 {`<br><br>`    required  bool required_bool  =  2;`<br><br>`  }`||`  type Group = {`<br>`    required_bool:`<br>`      bool @ 2: bool`<br>`  },`<br><br>`  group:`<br>`    Group @ 1`||
|| *Message Types* || ||
||`message Message {`<br>`  message Nested {`<br>`  }`<br><br>`  optional Nested optional_nested = 1;`<br><br>`};`<br><br>`message Type {`<br>`  required Message  required_message = 1;`<br><br>`};` ||`type Message = parsedmessage {`<br>`  type Nested = {`<br>`  },`<br><br>`  optional_nested:`<br>`    Message.Nested @ 1,`<br>`};`<br><br>`type Type = parsedmessage {`<br>`  required_message:`<br>`  Message @ 1,`<br>`};` ||
|| *Enums* || ||
||`message Foo {`<br><br>`  enum Enum {`<br>`    ONE   = 1;  `<br>`    TWO   = 2;`<br>`    THREE = 3;`<br>`  }`<br><br><br><br>`  required Enum required_enum = 1;`<br><br>`  optional Enum optional_enum = 2 [default = ONE];`<br><br>`  repeated Enum repeated_enum = 3;`<br><br>`};` ||`type Foo = parsedmessage {`<br>`  type Enum = int,`<br>`  static ONE: Enum = 1,`<br>`  static TWO: Enum = 2,`<br>`  static THREE: Enum = 3,`<br><br>`  static Enum_names: map[enum_value: int]`<br>`    of enum_name: string = {`<br>`    3: "THREE",`<br>`    2: "TWO",`<br>`    1: "ONE",`<br>`  },`<br>`  required_enum:`<br>`    Enum @ 1: int32,`<br>`  optional_enum:`<br>`    Enum = 1 @ 2: int32`<br>`  repeated_enum: array of`<br>`    Enum @ 3: int32`<br>`};`||
||`message Bar {`<br>`  required Foo.Enum required_enum = 1;`<br><br>`  optional Foo.Enum optional_enum = 2 [default = ONE];`<br><br>`  repeated Foo.Enum repeated_enum = 3;`<br><br>`};`||`type Bar = parsedmessage {  required_enum:`<br>`    Foo.Enum @ 1: int32,`<br>`  optional_enum:`<br>`    Foo.Enum = 1 @ 2: int32,`<br>`  repeated_enum: array of`<br>`    Foo.Enum @ 3: int32`<br>`};`||